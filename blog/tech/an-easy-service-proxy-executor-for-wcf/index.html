<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us>
<head>
<link href=https://gmpg.org/xfn/11 rel=profile>
<meta http-equiv=x-ua-compatible content="chrome=1">
<meta charset=utf-8>
<meta name=robots content="index,follow">
<meta name=apple-mobile-web-app-title content="Aashish Koirala">
<meta name=application-name content="Aashish Koirala">
<meta name=msapplication-TileColor content="#00aba9">
<meta name=theme-color content="#ffffff">
<meta charset=utf-8>
<meta name=generator content="Hugo 0.87.0">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>An Easy Service Proxy Executor for WCF &#183; Aashish Koirala</title>
<meta name=description content>
<link type=text/css rel=stylesheet href=https://aashishkoirala.github.io/css/print.css media=print>
<link type=text/css rel=stylesheet href=https://aashishkoirala.github.io/css/poole.css>
<link type=text/css rel=stylesheet href=https://aashishkoirala.github.io/css/syntax.css>
<link type=text/css rel=stylesheet href=https://aashishkoirala.github.io/css/hyde.css>
<link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">
<link rel=apple-touch-icon-precomposed sizes=144x144 href=https://aashishkoirala.github.io/apple-touch-icon.png>
<link rel=apple-touch-icon sizes=180x180 href=https://aashishkoirala.github.io/apple-touch-icon.png>
<link rel="shortcut icon" href=https://aashishkoirala.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://aashishkoirala.github.io/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=https://aashishkoirala.github.io/favicon-16x16.png>
<link rel=manifest href=https://aashishkoirala.github.io/site.webmanifest>
<link rel=mask-icon href=https://aashishkoirala.github.io/favicon-safari-pinned-tab.svg color=#5bbad5>
</head>
<body class=theme-base-0d>
<aside class=sidebar>
<div class="container sidebar-sticky">
<div class=sidebar-about>
<a href=https://aashishkoirala.github.io/>
<img src=https://aashishkoirala.github.io/logo.png alt="Aashish Koirala Software Developer. Overthinker.">
<h1>aashish<b>koirala</b></h1>
</a>
<p class=lead>Software Developer. Overthinker.</p>
</div>
<nav>
<ul class=sidebar-nav>
<li><a href=https://aashishkoirala.github.io/>Home</a> </li>
<li><a href=/about> About Me </a></li><li><a href=https://github.com/aashishkoirala/> Github </a></li><li><a href=https://twitter.com/aashishkoirala/> Twitter </a></li><li><a href=https://www.linkedin.com/in/aashishkoirala/> LinkedIn </a></li><li><a href=/blog/tech> Blog Posts - Tech </a></li><li><a href=/blog/nontech> Blog Posts - Non-Tech </a></li><li><a href=/index.xml> Subscribe (RSS) </a></li>
</ul>
</nav>
<p>&copy; 2021. All rights reserved. </p>
</div>
</aside>
<main class="content container">
<div class=post>
<h1>An Easy Service Proxy Executor for WCF</h1>
<time datetime=2014-05-15T00:00:00Z class=post-date>Thu, May 15, 2014</time>
<p>If you have adopted service oriented architecture (<a href=https://en.wikipedia.org/wiki/Service-oriented_architecture>SOA</a>) and are using WCF as the hosting/communication mechanism for your internal services, chances are you are doing one of two things: you publish each service like any old WCF service and your other services which are consumers of said published service consume it through its WSDL; or you create shared libraries that include the contract information that both the service and its consumer reference. Both are somewhat cumbersome but can be managed. If all your services are internal, though, going the WSDL route is somewhat of an unnecessary overhead and is just a bit more unmanageable.</p>
<p>Now, if you decide to go the second route, but still stick to the more obvious interface that WCF provides to instantiate and call proxies (<strong>ClientBase</strong> and the like), that is a bit of a waste - since those classes were built with generated-code proxies in mind. In that case, the better option really is to have a mechanism to obtain a <strong>ServiceEndpoint</strong> and use that along with the contract information to create your own <strong>ChannelFactory</strong> - where you can then call <em>CreateChannel</em> to get your proxy. A lot less code and a lot more manageable.</p>
<p>To this end, for my own purposes, I built a bunch of classes that comprise my WCF service executor module. This is part of the Services namespace in the new Commons Library. Here are what a few of the key classes look like - you should be able to surmise how they can be used. The most common usage example would be:</p>
<pre><code>var response = ServiceCallerFactory
   .Create&lt;IMyContract&gt;()
   .Call(x =&gt; x.MyOperation(request));
</code></pre>
<p><strong>IServiceCaller</strong></p>
<pre><code>public interface IServiceCaller&lt;out TChannel&gt;
{
     void Call(Action&lt;TChannel&gt; action);
     TResult Call&lt;TResult&gt;(Func&lt;TChannel, TResult&gt; action);
}
</code></pre>
<p><strong>ServiceCaller</strong></p>
<pre><code>public class ServiceCaller&lt;TChannel&gt; : IServiceCaller&lt;TChannel&gt;
{
      private readonly ServiceEndpoint endpoint;
      private readonly EndpointAddress endpointAddress;

      public ServiceCaller() {}

      public ServiceCaller(ServiceEndpoint endpoint)
       {
             this.endpoint = endpoint;
       }

      public ServiceCaller(EndpointAddress endpointAddress)
      {
             this.endpointAddress = endpointAddress;
      }

      public void Call(Action&lt;TChannel&gt; action)
      {
             var channelFactory = this.endpoint != null
                   ? new ChannelFactory&lt;TChannel&gt;(this.endpoint)
                   : new ChannelFactory&lt;TChannel&gt;();

            if (this.endpointAddress != null) channelFactory.Endpoint.Address = endpointAddress;

            var channel = channelFactory.CreateChannel();
             try
             {
                   action(channel);
             }
             catch
             {
                   channelFactory.Abort();
                   throw;
             }
             finally
             {
                   channelFactory.Close();
             }
       }

      public TResult Call&lt;TResult&gt;(Func&lt;TChannel, TResult&gt; action)
      {
             var channelFactory = this.endpoint != null
                   ? new ChannelFactory&lt;TChannel&gt;(this.endpoint)
                   : new ChannelFactory&lt;TChannel&gt;();

            var channel = channelFactory.CreateChannel();
             try
             {
                   return action(channel);
             }
             catch
             {
                   channelFactory.Abort();
                   throw;
             }
             finally
             {
                   channelFactory.Close();
             }
       }
}
</code></pre>
<p><strong>ServiceCallerFactory</strong></p>
<pre><code>public static class ServiceCallerFactory
{
      private static readonly object serviceCallerMapLock = new object();

      private static readonly IDictionary&lt;Type, ServiceCaller&gt; serviceCallerMap = new Dictionary&lt;Type, ServiceCaller&gt;();

      public static Func&lt;Type, ServiceEndpoint&gt; ServiceEndpointAccessor { get; set; }

      public static IServiceCaller&lt;TChannel&gt; Create&lt;TChannel&gt;(EndpointAddress endpointAddress = null)
      {
             ServiceCaller caller;
             if (serviceCallerMap.TryGetValue(typeof (TChannel), out caller))
                   return (IServiceCaller&lt;TChannel&gt;) caller;

            lock (serviceCallerMapLock)
            {
                   if (serviceCallerMap.TryGetValue(typeof (TChannel), out caller))
                         return (IServiceCaller&lt;TChannel&gt;) caller;

                   if (ServiceEndpointAccessor != null)
                   {
                         var serviceEndpoint = ServiceEndpointAccessor(typeof (TChannel));
                         if (endpointAddress != null) serviceEndpoint.Address = endpointAddress;
                         caller = new ServiceCaller&lt;TChannel&gt;(serviceEndpoint);
                   }
                   else
                   {
                         caller = endpointAddress == null
                               ? new ServiceCaller&lt;TChannel&gt;()
                               : new ServiceCaller&lt;TChannel&gt;(endpointAddress); 
                   }

                  serviceCallerMap[typeof (TChannel)] = caller;
            }

            return (IServiceCaller&lt;TChannel&gt;) caller;
      }
}</code></pre>
<div style=font-size:smaller>
<br><br>
Tags:
<a href=https://aashishkoirala.github.io/tags/csharp/>csharp</a> <a href=https://aashishkoirala.github.io/tags/dotnet/>dotnet</a> <a href=https://aashishkoirala.github.io/tags/soa/>soa</a> <a href=https://aashishkoirala.github.io/tags/wcf/>wcf</a>
<br>Previous:
<a href=https://aashishkoirala.github.io/blog/tech/bye-bye-typescript-for-now/>Bye, Bye, TypeScript, for now</a>
<br>Next:
<a href=https://aashishkoirala.github.io/blog/tech/getting-on-the-domain-driven-design-bandwagon/>Getting on the Domain-Driven Design Bandwagon</a>
</div>
</div>
</main>
</body>
</html>