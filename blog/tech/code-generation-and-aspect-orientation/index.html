<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta http-equiv=x-ua-compatible content="chrome=1"><meta charset=utf-8><meta name=robots content="index,follow"><meta name=apple-mobile-web-app-title content="Aashish Koirala"><meta name=application-name content="Aashish Koirala"><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><meta charset=utf-8><meta name=generator content="Hugo 0.105.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Code Generation And Aspect Orientation &#183; Aashish Koirala</title><meta name=description content><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/poole.css><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/syntax.css><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://aashishkoirala.com/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://aashishkoirala.com/apple-touch-icon.png><link rel="shortcut icon" href=https://aashishkoirala.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aashishkoirala.com/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://aashishkoirala.com/favicon-16x16.png><link rel=manifest href=https://aashishkoirala.com/site.webmanifest><link rel=mask-icon href=https://aashishkoirala.com/favicon-safari-pinned-tab.svg color=#5bbad5><meta property="og:title" content="Code Generation And Aspect Orientation"><meta property="og:description" content="TL;DR
The CodeDOM is a cool library within .NET that can be used for structured code generation and compilation. When combined with Reflection, one neat application is to be able to inject aspects into your code at run-time. I have created Aspects for .NET, a library that does just that, and also tries to bring AOP to MEF.
Whether it be generating boilerplate, generating proxy classes or processing DSL, code generation has numerous applications."><meta property="og:type" content="article"><meta property="og:url" content="https://aashishkoirala.com/blog/tech/code-generation-and-aspect-orientation/"><meta property="og:image" content="https://aashishkoirala.com/logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2014-02-26T00:00:00+00:00"><meta property="article:modified_time" content="2014-02-26T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aashishkoirala.com/logo.png"><meta name=twitter:title content="Code Generation And Aspect Orientation"><meta name=twitter:description content="TL;DR
The CodeDOM is a cool library within .NET that can be used for structured code generation and compilation. When combined with Reflection, one neat application is to be able to inject aspects into your code at run-time. I have created Aspects for .NET, a library that does just that, and also tries to bring AOP to MEF.
Whether it be generating boilerplate, generating proxy classes or processing DSL, code generation has numerous applications."></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://aashishkoirala.com/><img src=https://aashishkoirala.com/logo.png alt="Aashish Koirala Software Developer. Overthinker."><h1>aashish<b>koirala</b></h1></a><p class=lead>Software Developer. Overthinker.</p></div><nav><ul class=sidebar-nav><li><a href=https://aashishkoirala.com/>Home</a></li><li><a href=/about>About Me</a></li><li><a href=https://github.com/aashishkoirala/>Github</a></li><li><a href=https://twitter.com/aashishkoirala/>Twitter</a></li><li><a href=https://www.linkedin.com/in/aashishkoirala/>LinkedIn</a></li><li><a href=/blog/tech>Blog Posts - Tech</a></li><li><a href=/blog/nontech>Blog Posts - Non-Tech</a></li><li><a href=/index.xml>Subscribe (RSS)</a></li></ul></nav><p>&copy; 2022. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Code Generation And Aspect Orientation</h1><time datetime=2014-02-26T00:00:00Z class=post-date>Wed, Feb 26, 2014</time><blockquote><p><strong>TL;DR</strong></p></blockquote><p>The <a href="http://msdn.microsoft.com/en-us/library/y2k85ax6(v=vs.110).aspx">CodeDOM</a> is a cool library within .NET that can be used for structured code generation and compilation. When combined with <a href="http://msdn.microsoft.com/en-us/library/system.reflection(v=vs.110).aspx">Reflection</a>, one neat application is to be able to inject <a href=http://en.wikipedia.org/wiki/Aspect-oriented_programming>aspects</a> into your code at run-time. I have created <a href=http://aashishkoirala.github.io/aspects/>Aspects for .NET</a>, a library that does just that, and also tries to bring AOP to MEF.</p><p>Whether it be generating boilerplate, generating proxy classes or processing DSL, code generation has numerous applications. There are a few different options for code generation in .NET:</p><p><strong>T4:</strong> With <a href=http://msdn.microsoft.com/en-us/library/bb126445.aspx>T4</a> you create text templates that consist of literal text and &ldquo;special&rdquo; text that gets compiled, run and the output of the run inserted into the template to create the final output (a-la ASPX/Razor, etc.) If you need to generate code at design time off a model or DSL, this is your best bet. You can extend the T4 library and write stuff that does runtime code generation too. In that case though, you would be playing around with code in string literals. Not ideal.</p><p><strong>CodeDOM:</strong> I feel that <a href="http://msdn.microsoft.com/en-us/library/y2k85ax6(v=vs.110).aspx">CodeDOM</a> is a somewhat under-appreciated part of the .NET framework in that it does not get a lot of buzz (or at least that has been my impression). I am not sure what impact the introduction of <a href=http://msdn.microsoft.com/en-us/vstudio/roslyn.aspx>Roslyn</a> will have on it, but as of right now I love it the way it is. It is a DOM based approach to working with programmatically constructed code. The entire .NET type system is represented as different node types in the DOM. You can construct a DOM from scratch, or parse existing code into a DOM. Given a DOM, you can generate code in a given language (provided you have the code provider), or compile the DOM on-the-fly into an assembly that you can then load up and use. That is cool in my book any day.</p><p>Another cool approach is to combine the two- write classes that use CodeDOM to generate code as a string, and then use that in T4 templates. In any case, I think the choice depends on whether you want your code generated at design time or run-time.</p><p><strong>Design Time:</strong> You would need to do this if there is non-generated code in your application that references constructs from within the generated code. The burden of having to keep generated code around in source control could be somewhat alleviated by having the generation take place as part of the build. In that case, also, however, until you build, the rest of your code is going to have a lot of squiggly red lines. Now, if the rest of your code only referenced interfaces and the implementations were generated, assuming you were using some sort of dependency injection mechanism, that would be a solution. However, that is not the norm with T4 (i.e. generating only on build).</p><p><strong>Run-Time:</strong> With this strategy, you would generate code at run-time (most probably using CodeDOM to generate an in-memory assembly), load that up using <a href="http://msdn.microsoft.com/en-us/library/system.reflection(v=vs.110).aspx">Reflection</a> or <a href="http://msdn.microsoft.com/en-us/library/dd460648(v=vs.110).aspx">MEF</a> or what-have-you and then use it. Preferably you would want this to happen at startup or very infrequently for performance reasons. In this case, also, you would need a minimal set of constructs that the rest of your code can reference that provides a bridge to the generated code. An example of this would again be non-generated interfaces with generated implementations.</p><p>As I think about it, there are two applications that I have been wanting to use run-time code generation for:</p><ul><li>Generating WCF proxies when we have a reference to the service/data contracts (although increasingly I have been thinking that might be unnecessary, that&rsquo;s another blog post to come).</li><li><strong><a href=http://en.wikipedia.org/wiki/Aspect-oriented_programming>Aspect oriented programming</a></strong>, or more accurately introducing aspects into my implementation code.</li></ul><p>Now, aspects as a concept is quite good. To be able to remove cross-cutting stuff from your business logic code is always good. The attribute model in .NET is a very good fit for applying aspects. There are a few issues with what prevails in terms of AOP in .NET though:</p><ul><li><a href=http://www.postsharp.net/>PostSharp</a>: They&rsquo;re pretty popular within the AOP crowd, but I don&rsquo;t like my code messed with post-compilation.</li><li>There are IoC containers that support AOP out of the box, but I don&rsquo;t like to tie myself to any one container just because they support AOP; besides I have been using <a href=https://aashishkoirala.com/blog/tech/mef-for-everything/>MEF for everything</a>.</li><li>MEF does not have AOP support.</li><li>If you peruse through NuGet, there are quite a few AOP libraries out there. If you think about it, though, this is a perfect application for run-time code generation. I already have CodeDOM and Reflection in my toolbox. Why not build it in the spirit of <a href=https://aashishkoirala.com/blog/tech/on-rolling-your-own/>rolling my own</a>? I can then build it the way I think makes sense and build it with MEF support in mind.</li></ul><p>To that effect, I ended up writing <strong><a href=http://aashishkoirala.github.io/aspects/>Aspects for .NET</a></strong>. It is a library that provides interfaces that you can implement to build your own aspects which you can then apply to your implementation classes. It provides a mechanism to wrap, at runtime, your implementation with aspects. There is also integrated support for MEF, albeit with some limitations.</p><p>You can visit the <a href=http://aashishkoirala.github.io/aspects/>project page</a> or the <a href=https://github.com/aashishkoirala/aspects>GitHub repo</a> for more detailed documentation, but to summarize, you can &ldquo;wrap&rdquo; a class with aspects at run-time. When you do so, it inspects the contract interface and implementation class using reflection. It uses CodeDOM to generate an on-the-fly implementation of the contract interface, which expects an instance of the implementation to be initialized, and where each member simply calls out to the implementation (i.e. a hollow wrapper). However, in the process, it also inspects the implementation member to see if any aspect attributes are applied and adds code at appropriate places before or after the invocation to execute those aspects. The type that is generated on the fly is cached in memory.</p><p>As with everything else, there is always room for improvement and feedback is welcome.</p><div style=font-size:smaller><br><br>Tags:
<a href=https://aashishkoirala.com/tags/csharp/>csharp</a> <a href=https://aashishkoirala.com/tags/dotnet/>dotnet</a> <a href=https://aashishkoirala.com/tags/aop/>aop</a> <a href=https://aashishkoirala.com/tags/architecture/>architecture</a> <a href=https://aashishkoirala.com/tags/modeling/>modeling</a><br>Previous:
<a href=https://aashishkoirala.com/blog/tech/reader-writer-locking-in-dotnet/>Reader Writer Locking In .NET</a><br>Next:
<a href=https://aashishkoirala.com/blog/tech/getting-functional-with-perhaps/>Getting Functional With Perhaps</a></div></div><h2>Comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//aashishkoirala.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></main><script async src="https://www.googletagmanager.com/gtag/js?id=G-1VD1W7LBR1"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1VD1W7LBR1",{anonymize_ip:!1})}</script></body></html>