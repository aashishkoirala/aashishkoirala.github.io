<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta http-equiv=X-UA-Compatible content="chrome=1"><meta charset=utf-8><meta name=robots content="index,follow"><meta name=apple-mobile-web-app-title content="Aashish Koirala"><meta name=application-name content="Aashish Koirala"><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><meta charset=utf-8><meta name=generator content="Hugo 0.145.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Writing Your Own LINQ Provider- Part 2 &#183; Aashish Koirala</title>
<meta name=description content><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/poole.css><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/syntax.css><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://aashishkoirala.com/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://aashishkoirala.com/apple-touch-icon.png><link rel="shortcut icon" href=https://aashishkoirala.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aashishkoirala.com/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://aashishkoirala.com/favicon-16x16.png><link rel=manifest href=https://aashishkoirala.com/site.webmanifest><link rel=mask-icon href=https://aashishkoirala.com/favicon-safari-pinned-tab.svg color=#5bbad5><meta property="og:url" content="https://aashishkoirala.com/blog/tech/writing-your-own-linq-provider-part-2/"><meta property="og:site_name" content="Aashish Koirala"><meta property="og:title" content="Writing Your Own LINQ Provider- Part 2"><meta property="og:description" content="This is the second in a short series of posts on writing your own LINQ provider. A quick outline of the series:
A primer Provider basics (this post) A simple, pointless solution A tiny ORM of our own Provider Basics In the previous post, we took a look at the two flavors of LINQ methods, i.e. the methods and classes around IEnumerable<T> and the methods and classes around IQueryable<T>. In this post, we expand upon what happens when you call LINQ methods on IQueryable<T>, and how you can use that to build your own provider."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2014-03-12T00:00:00+00:00"><meta property="article:modified_time" content="2014-03-12T00:00:00+00:00"><meta property="article:tag" content="Csharp"><meta property="article:tag" content="Dotnet"><meta property="article:tag" content="Linq"><meta property="og:image" content="https://aashishkoirala.com/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aashishkoirala.com/logo.png"><meta name=twitter:title content="Writing Your Own LINQ Provider- Part 2"><meta name=twitter:description content="This is the second in a short series of posts on writing your own LINQ provider. A quick outline of the series:
A primer Provider basics (this post) A simple, pointless solution A tiny ORM of our own Provider Basics In the previous post, we took a look at the two flavors of LINQ methods, i.e. the methods and classes around IEnumerable<T> and the methods and classes around IQueryable<T>. In this post, we expand upon what happens when you call LINQ methods on IQueryable<T>, and how you can use that to build your own provider."></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://aashishkoirala.com/><img src=https://aashishkoirala.com/logo.png alt="Aashish Koirala Software Developer. Overthinker."><h1>aashish<b>koirala</b></h1></a><p class=lead>Software Developer. Overthinker.</p></div><nav><ul class=sidebar-nav><li><a href=https://aashishkoirala.com/>Home</a></li><li><a rel=me href=/about>About Me</a></li><li><a rel=me href=https://github.com/aashishkoirala/>Github</a></li><li><a rel=me href=https://twitter.com/aashishkoirala/>Twitter</a></li><li><a rel=me href=https://hachyderm.io/@aashishkoirala>Mastodon</a></li><li><a rel=me href=https://www.linkedin.com/in/aashishkoirala/>LinkedIn</a></li><li><a rel=me href=/blog/tech>Blog Posts - Tech</a></li><li><a rel=me href=/blog/nontech>Blog Posts - Non-Tech</a></li><li><a rel=me href=/index.xml>Subscribe (RSS)</a></li></ul></nav><p>&copy; 2025. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Writing Your Own LINQ Provider- Part 2</h1><time datetime=2014-03-12T00:00:00Z class=post-date>Wed, Mar 12, 2014</time><p>This is the second in a short series of posts on writing your own LINQ provider. A quick outline of the series:</p><ol><li><a href=https://aashishkoirala.com/blog/tech/writing-your-own-linq-provider-part-1/>A primer</a></li><li><strong>Provider basics</strong> (<em>this post</em>)</li><li><a href=https://aashishkoirala.com/blog/tech/writing-your-own-linq-provider-part-3/>A simple, pointless solution</a></li><li><a href=https://aashishkoirala.com/blog/tech/writing-your-own-linq-provider-part-4/>A tiny ORM of our own</a></li></ol><hr><h3 id=provider-basics>Provider Basics</h3><p>In the <a href=https://aashishkoirala.com/blog/tech/writing-your-own-linq-provider-part-1/>previous post</a>, we took a look at the two flavors of LINQ methods, i.e. the methods and classes around <code>IEnumerable&lt;T></code> and the methods and classes around <code>IQueryable&lt;T></code>. In this post, we expand upon what happens when you call LINQ methods on <code>IQueryable&lt;T></code>, and how you can use that to build your own provider.</p><p>Once you have an instance of <code>IQueryable&lt;T></code>, you can do one of three things with it:</p><ol><li>Enumerate it, using one of the following methods:<ol><li>Call a method such as <code>ToList</code>, <code>ToArray</code> or <code>ToDictionary</code> on it.</li><li>Use it in a <code>foreach</code> loop.</li><li>Call <code>GetEnumerator()</code> and then use the enumerator you get in the usual way.</li></ol></li><li>Call a LINQ method that returns a scalar result (this also results in the queryable getting enumerated) such as <code>Any</code>, <code>First</code>, <code>All</code>, <code>Single</code>, etc.</li><li>Call a LINQ method (such as <code>Where</code>, <code>Select</code>, <code>OrderBy</code> etc.) that returns another <code>IQueryable</code> with some rules added that you can again do one of these very three things with.</li></ol><p>For the first situation, <code>IQueryable</code> behaves just like any <code>IEnumerable</code> in that the <code>GetEnumerator()</code> method is called - so this is where you implement what you want to happen when the final enumeration happens. Usually, you do this by writing your own implementation of <code>IEnumerator&lt;T></code> for this purpose that you return from the <code>GetEnumerator()</code> method.</p><p>For the remaining two situations, the <code>Provider</code> and <code>Expression</code> properties of <code>IQueryable&lt;T></code> come into play. When you implement <code>IQueryable&lt;T></code>, you need to implement the getter for the <code>Provider</code> property to return an implementation of <code>IQueryProvider&lt;T></code> that does what you want.</p><p>In both cases, here is what the LINQ methods do:</p><ol><li>Create a lambda expression that represents the LINQ method call.</li><li>Get a reference to the <code>Provider</code> for the target <code>IQueryable&lt;T></code>.</li><li>For the first case, call <code>Execute</code> on the <code>IQueryProvider&lt;T></code> from step 2. For the second case, call <code>CreateQuery</code> on the &lsquo;IQueryProvider` from step 2.</li><li>The only thing that is different across different LINQ methods is the type parameters that are passed in, e.g. <code>Any&lt;T></code> will call <code>Execute&lt;bool></code> while <code>First</code> will call <code>Execute&lt;T></code>. Similarly, <code>Where&lt;T></code> will call <code>CreateQuery&lt;T></code> while <code>Select&lt;TSource, TResult></code> will call <code>CreateQuery&lt;TResult></code>.</li></ol><p>To drive the point home, here is the simplified source code for <code>Where&lt;T></code>:</p><pre><code>public static IQueryable&lt;T&gt; Where&lt;T&gt;(
	this IQueryable&lt;T&gt; source, 
	Expression&lt;Func&lt;T, bool&gt;&gt; predicate)
{
    var currentMethodOpen = (MethodInfo) MethodBase.GetCurrentMethod();
    var currentMethod = currentMethodOpen.MakeGenericMethod(new[] {typeof (T)});
    var callArguments = new[] { source.Expression, Expression.Quote(predicate) };
    var callExpression = Expression.Call(null, currentMethod, callArguments);

    return source.Provider.CreateQuery&lt;T&gt;(callExpression);
}
</code></pre><p>And here is the simplified source code for <code>Any&lt;T></code>:</p><pre><code>public static bool Any&lt;T&gt;(this IQueryable&lt;T&gt; source, Expression&lt;Func&lt;T, bool&gt;&gt; predicate)
{
    var currentMethodOpen = (MethodInfo) MethodBase.GetCurrentMethod();
    var currentMethod = currentMethodOpen.MakeGenericMethod(new[] {typeof (T)});

    return source.Provider.Execute&lt;bool&gt;(Expression.Call(
		null, currentMethod, new[] {source.Expression}));
}
</code></pre><p>Note how neither method body does anything specific to what a &ldquo;Where&rdquo; or &ldquo;Any&rdquo; operation should do. It just wraps that information in an expression and calls the appropriate method on the <code>Provider</code>. It is up to the provider to understand the expression (which is passed in as a parameter to both <code>CreateQuery</code> and <code>Execute</code>) and perform the correct operation. This is why when you build a LINQ provider, it is up to you to write the translation logic for each LINQ operation as it relates to your data source, or write a fallback that says &ldquo;this operation is not supported.&rdquo;</p><p>Creating a new LINQ provider, then, can be boiled down to the following steps:</p><p><strong>Step 1</strong></p><p>Create a class that implements <code>IQueryable&lt;T></code> (say, <code>YourQueryable&lt;T></code>).</p><ol><li>There should be a way to construct this class and pass in some sort of an interface to the underlying data source to use (e.g. in NHibernate, <code>session.Query&lt;T></code> on the NHibernate <code>ISession</code> object does this).</li><li>The call to <code>GetEnumerator()</code> should return your implementation of <code>IEnumerator&lt;T></code>, (say, <code>YourEnumerator&lt;T></code>). It should be initialized with the value of <code>YourQueryable.Expression</code> at the time of the call.</li><li>The getter for the <code>Provider</code> property should return an instance of <code>IQueryProvider&lt;T></code> (say, <code>YourQueryProvider&lt;T></code>). The provider should have access to the underlying data source interface.</li></ol><p><strong>Step 2: Option 1</strong></p><p>The logic to parse the final expression can go in <code>YourEnumerator&lt;T></code>. In this case, <code>YourQueryProvider.CreateQuery</code> simply returns a new instance of <code>YourQueryable&lt;T></code> but with the <code>Expression</code> set to what is passed in to <code>CreateQuery</code>. The very first instance of <code>YourQueryable&lt;T></code> would then set the <code>Expression</code> to <code>Expression.Constant(this)</code>. This way, when the time comes to enumerate and you get to <code>YourEnumerator&lt;T></code>, you have an expression that represents the complete call chain. That is where you then put the hard part of parsing that so that the first call to <code>MoveNext</code> does the right thing against the underlying data source.</p><p><strong>Step 2: Option 2</strong></p><p>Another option is to have a dumb <code>YourEnumerator&lt;T></code> and instead have a separate implementation of <code>IQueryable&lt;T></code> for each type of query operation to support (e.g. <code>WhereQueryable', </code>SelectQueryable&rsquo;, etc.) In this case, the parsing logic is spread out across these classes, and <code>YourQueryProvider.CreateQuery</code> needs to examine the expression then and there return the correct type of <code>IQueryable&lt;T></code> with all the necessary information wrapped within. In any case, though, the expression as a whole must be parsed before enumeration happens.</p><p><strong>Step 3</strong></p><p><code>YourQueryProvider.Execute</code> then needs to have logic that parses the expression passed in, figures out what needs to be done and return the result. This may involve enumerating the underlying <code>IQueryable&lt;T></code>. Going back to an ORM that is based on SQL Server, say, you would need to know to generate an <code>WHERE EXISTS</code> clause if you spot an <code>Any</code> in the expression.</p><p>Now, granted, all of this sounds pretty convoluted and can be hard to get a grip on without an example. So, we will do just that in the next post. We will start with a simple but pointless solution that does LINQ just for the sake of LINQ. Then, we&rsquo;ll try to build a rudimentary ORM of our own.</p><div style=font-size:smaller><br><br>Tags:
<a href=https://aashishkoirala.com/tags/csharp/>csharp</a> <a href=https://aashishkoirala.com/tags/dotnet/>dotnet</a> <a href=https://aashishkoirala.com/tags/linq/>linq</a><br>Previous:
<a href=https://aashishkoirala.com/blog/tech/writing-your-own-linq-provider-part-1/>Writing Your Own LINQ Provider- Part 1</a><br>Next:
<a href=https://aashishkoirala.com/blog/tech/writing-your-own-linq-provider-part-3/>Writing Your Own LINQ Provider- Part 3</a></div></div></main></body></html>