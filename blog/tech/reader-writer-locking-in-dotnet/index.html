<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta http-equiv=x-ua-compatible content="chrome=1"><meta charset=utf-8><meta name=robots content="index,follow"><meta name=apple-mobile-web-app-title content="Aashish Koirala"><meta name=application-name content="Aashish Koirala"><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><meta charset=utf-8><meta name=generator content="Hugo 0.107.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Reader Writer Locking In .NET &#183; Aashish Koirala</title><meta name=description content><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/poole.css><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/syntax.css><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://aashishkoirala.com/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://aashishkoirala.com/apple-touch-icon.png><link rel="shortcut icon" href=https://aashishkoirala.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aashishkoirala.com/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://aashishkoirala.com/favicon-16x16.png><link rel=manifest href=https://aashishkoirala.com/site.webmanifest><link rel=mask-icon href=https://aashishkoirala.com/favicon-safari-pinned-tab.svg color=#5bbad5><meta property="og:title" content="Reader Writer Locking In .NET"><meta property="og:description" content="Quite often people turn to the lock statement when protecting access to shared resources from multiple threads. A lot of times, though, this is too big of a hammer. This is because to maintain the integrity of the lock, any access of the protected resource, be it simply accessing its value or modifying it, needs to be done within the lock. This means even concurrent reads get serialized. A lot of times, what you need is for concurrent reads to be possible as long as they read a consistent value, while writes are serialized."><meta property="og:type" content="article"><meta property="og:url" content="https://aashishkoirala.com/blog/tech/reader-writer-locking-in-dotnet/"><meta property="og:image" content="https://aashishkoirala.com/logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2014-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2014-02-18T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aashishkoirala.com/logo.png"><meta name=twitter:title content="Reader Writer Locking In .NET"><meta name=twitter:description content="Quite often people turn to the lock statement when protecting access to shared resources from multiple threads. A lot of times, though, this is too big of a hammer. This is because to maintain the integrity of the lock, any access of the protected resource, be it simply accessing its value or modifying it, needs to be done within the lock. This means even concurrent reads get serialized. A lot of times, what you need is for concurrent reads to be possible as long as they read a consistent value, while writes are serialized."></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://aashishkoirala.com/><img src=https://aashishkoirala.com/logo.png alt="Aashish Koirala Software Developer. Overthinker."><h1>aashish<b>koirala</b></h1></a><p class=lead>Software Developer. Overthinker.</p></div><nav><ul class=sidebar-nav><li><a href=https://aashishkoirala.com/>Home</a></li><li><a rel=me href=/about>About Me</a></li><li><a rel=me href=https://github.com/aashishkoirala/>Github</a></li><li><a rel=me href=https://twitter.com/aashishkoirala/>Twitter</a></li><li><a rel=me href=https://hachyderm.io/@aashishkoirala>Mastodon</a></li><li><a rel=me href=https://www.linkedin.com/in/aashishkoirala/>LinkedIn</a></li><li><a rel=me href=/blog/tech>Blog Posts - Tech</a></li><li><a rel=me href=/blog/nontech>Blog Posts - Non-Tech</a></li><li><a rel=me href=/index.xml>Subscribe (RSS)</a></li></ul></nav><p>&copy; 2022. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Reader Writer Locking In .NET</h1><time datetime=2014-02-18T00:00:00Z class=post-date>Tue, Feb 18, 2014</time><p>Quite often people turn to the <a href=http://msdn.microsoft.com/en-us/library/c5kehkcz.aspx><code>lock</code></a> statement when protecting access to shared resources from multiple threads. A lot of times, though, this is too big of a hammer. This is because to maintain the integrity of the lock, any access of the protected resource, be it simply accessing its value or modifying it, needs to be done within the lock. This means even concurrent reads get serialized. A lot of times, what you need is for concurrent reads to be possible as long as they read a consistent value, while writes are serialized.</p><p>This is exactly what reader/writer locking is for. I ran into the same scenario while building <a href=https://aashishkoirala.com/blog/tech/rudymq-a-rudimentary-message-queue-for-windows/>RudyMQ</a> and the framework class <a href="http://msdn.microsoft.com/en-us/library/system.threading.readerwriterlockslim(v=vs.110).aspx"><code>ReaderWriterLockSlim</code></a> class came in handy (in case you&rsquo;re wondering about the &ldquo;slim&rdquo; in the name, this class is supposed to be a slimmed down, more efficient version of the now somewhat deprecated <a href="http://msdn.microsoft.com/en-us/library/system.threading.readerwriterlock(v=vs.110).aspx"><code>ReaderWriterLock</code></a> class).</p><p>Here is a very simplified rundown of how <code>ReaderWriterLockSlim</code> works. Given an object <code>rwls</code> of type <code>ReaderWriterLockSlim</code>:</p><pre><code>// This will block if another thread has entered a write lock
// on &quot;rwls&quot;.
rwls.EnterReadLock();

try
{
    // Read value of protected resource here.
    // While here, all calls to &quot;rwls.EnterWriteLock()&quot; will be blocked.
}
finally
{
    rwls.ExitReadLock();
}
</code></pre><p>And similarly for writes:</p><pre><code>// This will block if another thread has entered a read OR write lock
// on &quot;rwls&quot;.
rwls.EnterWriteLock();

try
{
    // Write/modify protected resource here.
    // While here, all calls to &quot;rwls.EnterWriteLock()&quot; and 
	// &quot;rwls.EnterReadLock()&quot; will be blocked.
}
finally
{
    rwls.ExitWriteLock();
}
</code></pre><p>Now, as easy as that is, that is just a little more boilerplate than I&rsquo;m willing to write. Also, <code>ReaderWriterLockSlim</code> is an <code>IDisposable</code>, which brings with it all the boilerplate associated with that whenever you have to manage one or more instances of it.</p><p>My solution was to create a monadish wrapper around this called, say, <code>LockedObject&lt;T></code>, that handles all that, and wraps the actual protected resource along with an accompanying lock instance, something along the lines of:</p><pre><code>public class LockedObject&lt;T&gt;
{
   private readonly ReaderWriterLockSlim readerWriterLockSlim;
   private T value;
   
   public LockedObject(T value)
   {
       this.value = value;
       this.readerWriterLockSlim = new ReaderWriterLockSlim();
   }

   // ... IDisposable related boilerplate
  
   // An overload of this using Action&lt;T&gt; not shown.
   public TResult ExecuteRead&lt;TResult&gt;(Func&lt;T, TResult&gt; action)
   {
       this.readerWriterLockSlim.EnterReadLock();

       try
       {
           return action(this.value);
       }
       finally
       {
           this.readerWriterLockSlim.ExitReadLock();
       }
   }

   // An overload of this using Action&lt;T&gt; not shown.
   public TResult ExecuteWrite&lt;TResult&gt;(Func&lt;T, TResult&gt; action)
   {
       this.readerWriterLockSlim.EnterWriteLock();

       try
       {
           return action(this.value);
       }
       finally
       {
           this.readerWriterLockSlim.ExitWriteLock();
       }
   }

   public void Update(T newValue)
   {
       this.ExecuteWrite(v =&gt; this.value = newValue, timeout);
   }
}
</code></pre><p>For strictly value-based types and primitive types, we could take this one step further and create a <code>LockedValue&lt;T></code> that looks like:</p><pre><code>public class LockedValue&lt;T&gt; : LockedObject&lt;T&gt; where T : struct
{
    public LockedValue(T value) : base(value) {}

    public T Value
    {
        get { return this.ExecuteRead(v =&gt; v); }
        set { this.Update(value); }
    }
}
</code></pre><p>When you think about how those classes can then be used, I think it cuts down on quite a bit of the boilerplate - and that is usually good.</p><p><strong>UPDATE</strong></p><p>I am working on building these classes into the <a href=https://aashishkoirala.com/blog/tech/the-commons-library/>Commons Library</a>. You can find the full source code for these classes as follows:</p><ul><li><a href=https://github.com/aashishkoirala/commons/blob/develop/src/AK.Commons/Threading/LockedObject.cs>Source code for <code>LockedObject</code></a></li><li><a href=https://github.com/aashishkoirala/commons/blob/develop/src/AK.Commons/Threading/LockedValue.cs>Source code for <code>LockedValue</code></a></li></ul><div style=font-size:smaller><br><br>Tags:
<a href=https://aashishkoirala.com/tags/csharp/>csharp</a> <a href=https://aashishkoirala.com/tags/dotnet/>dotnet</a> <a href=https://aashishkoirala.com/tags/threads/>threads</a><br>Previous:
<a href=https://aashishkoirala.com/blog/tech/rudymq-a-rudimentary-message-queue-for-windows/>RudyMQ- A Rudimentary Message Queue for Windows</a><br>Next:
<a href=https://aashishkoirala.com/blog/tech/code-generation-and-aspect-orientation/>Code Generation And Aspect Orientation</a></div></div><h2>Comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//aashishkoirala.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></main><script async src="https://www.googletagmanager.com/gtag/js?id=G-1VD1W7LBR1"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1VD1W7LBR1",{anonymize_ip:!1})}</script></body></html>