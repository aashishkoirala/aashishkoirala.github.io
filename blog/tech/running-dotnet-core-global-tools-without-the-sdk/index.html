<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta http-equiv=x-ua-compatible content="chrome=1"><meta charset=utf-8><meta name=robots content="index,follow"><meta name=apple-mobile-web-app-title content="Aashish Koirala"><meta name=application-name content="Aashish Koirala"><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><meta charset=utf-8><meta name=generator content="Hugo 0.107.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Running .NET Core Global Tools Without the SDK &#183; Aashish Koirala</title><meta name=description content><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/poole.css><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/syntax.css><link type=text/css rel=stylesheet href=https://aashishkoirala.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://aashishkoirala.com/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://aashishkoirala.com/apple-touch-icon.png><link rel="shortcut icon" href=https://aashishkoirala.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aashishkoirala.com/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://aashishkoirala.com/favicon-16x16.png><link rel=manifest href=https://aashishkoirala.com/site.webmanifest><link rel=mask-icon href=https://aashishkoirala.com/favicon-safari-pinned-tab.svg color=#5bbad5><meta property="og:title" content="Running .NET Core Global Tools Without the SDK"><meta property="og:description" content=".NET Core Global Tools are pretty neat. If you are targetting developers with the .NET Core SDK installed on their machines and need to ship CLI tools, your job is made immensely easier. It is just as easy as shipping a NuGet package. However, once you get used to building these things, it is easy to fall into the trap of treating this shipping mechanism as if it were Chocolatey (or apt-get, or yum, or what-have-you)."><meta property="og:type" content="article"><meta property="og:url" content="https://aashishkoirala.com/blog/tech/running-dotnet-core-global-tools-without-the-sdk/"><meta property="og:image" content="https://aashishkoirala.com/logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-09-06T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-06T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aashishkoirala.com/logo.png"><meta name=twitter:title content="Running .NET Core Global Tools Without the SDK"><meta name=twitter:description content=".NET Core Global Tools are pretty neat. If you are targetting developers with the .NET Core SDK installed on their machines and need to ship CLI tools, your job is made immensely easier. It is just as easy as shipping a NuGet package. However, once you get used to building these things, it is easy to fall into the trap of treating this shipping mechanism as if it were Chocolatey (or apt-get, or yum, or what-have-you)."></head><body class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://aashishkoirala.com/><img src=https://aashishkoirala.com/logo.png alt="Aashish Koirala Software Developer. Overthinker."><h1>aashish<b>koirala</b></h1></a><p class=lead>Software Developer. Overthinker.</p></div><nav><ul class=sidebar-nav><li><a href=https://aashishkoirala.com/>Home</a></li><li><a rel=me href=/about>About Me</a></li><li><a rel=me href=https://github.com/aashishkoirala/>Github</a></li><li><a rel=me href=https://twitter.com/aashishkoirala/>Twitter</a></li><li><a rel=me href=https://hachyderm.io/@aashishkoirala>Mastodon</a></li><li><a rel=me href=https://www.linkedin.com/in/aashishkoirala/>LinkedIn</a></li><li><a rel=me href=/blog/tech>Blog Posts - Tech</a></li><li><a rel=me href=/blog/nontech>Blog Posts - Non-Tech</a></li><li><a rel=me href=/index.xml>Subscribe (RSS)</a></li></ul></nav><p>&copy; 2022. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>Running .NET Core Global Tools Without the SDK</h1><time datetime=2019-09-06T00:00:00Z class=post-date>Fri, Sep 6, 2019</time><p><a href=https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools>.NET Core Global Tools</a> are pretty neat. If you are targetting developers with the .NET Core SDK installed on their machines and need to ship CLI tools, your job is made immensely easier. It is just as easy as shipping a NuGet package. However, once you get used to building these things, it is easy to fall into the trap of treating this shipping mechanism as if it were <a href=https://chocolatey.org/>Chocolatey</a> (or <em>apt-get</em>, or <em>yum</em>, or what-have-you). It is certainly not that. The process of installing and upgrading your tools are handled by the .NET Core SDK - which alleviates you from having to create a self-contained package if you were shipping a ready-to-go tool - and this makes sense - global tools are a developer-targetted thing. You&rsquo;re not supposed to use it to distribute end-user applications.</p><p>However, there is a use case in the middle that warrants some resolution, and that is - being able to install and run a .NET Core Global Tool on a machine that has the .NET Core Runtime installed but not the SDK. A good example of this is if, as part of my deployment pipeline, I need to build a <strong>Docker Container</strong> image that is supposed to run in production and therefore has the Runtime installed but not the SDK - and it needs this tool installed in the container.</p><p>In this scenario, the following is what I do:</p><ul><li>As part of the deployment pipeline, install the tool on the deployment machine itself (or hosted agent or whatever if you&rsquo;re using a CI/CD pipeline tool)- which is going to have the SDK since you&rsquo;re building and deploying stuff from it.</li><li>As part of installing the tool, the SDK will then create a folder where the tool is published so as to be self-contained (not TOTALLY self-contained, it will still need the Runtime, of course).</li><li>As part of your Docker image build, add a <em>COPY</em> line to your <em>DOCKERFILE</em> to copy the tool files to your container image.</li></ul><p><strong>Example</strong></p><p>Let&rsquo;s say I have a global tool called <strong>mytool</strong> that is published to NuGet with version <strong>1.0.0</strong>. Then, If I run the following:</p><pre><code>dotnet tool install -g mytool
</code></pre><p>The tool ends up getting installed in the <em>UserProfile</em><strong>/.dotnet/tools/</strong> directory (where <em>UserProfile</em> would commonly be <strong>/Users/</strong><em>username</em> in Windows and <strong>/home/</strong><em>username</em> in Linux). You can further control the install path using the <code>--tool-path</code> option rather than the <code>-g</code> (or <code>--global</code>) option - if that makes your job easier.</p><p>In the above mentioned folder, it creates a platform-native executable shim with the actual files residing inside a <strong>.store</strong> directory. So, going back to the <strong>mytool</strong> example, you could have the directory structure as follows:</p><pre><code>UserProfile/.dotnet/tools/.store/mytool/1.0.0/pfxtool/1.0.0/tools/netcoreapp2.2/any
</code></pre><p>The above is just an example. The actual structure will be similar but could vary depending on what TFMs the tool targets and how the NUPKG is packaged and is thus exploded by the installer. In any case, inside this directory will be the set of files that make up this tool along with the main startup assembly (say <strong>mytool.dll</strong>) that you can invoke by switching to this directory and running:</p><pre><code>dotnet mytool.dll
</code></pre><p>You can use this mechanism to then set up your <em>DOCKERFILE</em> to copy the files to a well-defined location inside the container. Perhaps you can add the well-defined location to <em>PATH</em> or add a shim shell script to invoke it to make things easier. It&rsquo;s all a bit cumbersome but it works. Of course, if you OWN the tool, you could just publish it differently with <code>dotnet publish</code> - but in cases where you need to use a published tool in your production runtime environment, this helps.</p><div style=font-size:smaller><br><br>Tags:
<a href=https://aashishkoirala.com/tags/csharp/>csharp</a> <a href=https://aashishkoirala.com/tags/dotnetcore/>dotnetcore</a> <a href=https://aashishkoirala.com/tags/docker/>docker</a> <a href=https://aashishkoirala.com/tags/containers/>containers</a><br>Previous:
<a href=https://aashishkoirala.com/blog/tech/azure-devops-for-ci-and-cd/>Azure DevOps for CI and CD</a><br>Next:
<a href=https://aashishkoirala.com/blog/tech/installing-pfx-certificates-in-docker-containers/>Installing PFX Certificates in Docker Containers</a></div></div><h2>Comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//aashishkoirala.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></main><script async src="https://www.googletagmanager.com/gtag/js?id=G-1VD1W7LBR1"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1VD1W7LBR1",{anonymize_ip:!1})}</script></body></html>