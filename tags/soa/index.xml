<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Soa on Aashish Koirala</title><link>https://aashishkoirala.com/tags/soa/</link><description>Recent content in Soa on Aashish Koirala</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 13 Aug 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://aashishkoirala.com/tags/soa/index.xml" rel="self" type="application/rss+xml"/><item><title>DDD, meet SOA</title><link>https://aashishkoirala.com/blog/tech/ddd-meet-soa/</link><pubDate>Wed, 13 Aug 2014 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/ddd-meet-soa/</guid><description>&lt;p>There is a lot of discussion online around whether &lt;a href="https://en.wikipedia.org/wiki/Domain-driven_design">DDD&lt;/a> and &lt;a href="https://en.wikipedia.org/wiki/Service-oriented_architecture">SOA&lt;/a> can co-exist, and if so, what that looks like. I am of the opinion that they can co-exist and have arrived at a model that seems to work for me. Consider a complex DDD system with several bounded contexts and contrast it to an SOA system - and I am including the flavor of SOA that I describe in &lt;a href="https://aashishkoirala.com/blog/tech/a-method-for-service-oriented-architecture-soa/">this post&lt;/a>.&lt;/p></description></item><item><title>A Method for Service-Oriented Architecture (SOA)</title><link>https://aashishkoirala.com/blog/tech/a-method-for-service-oriented-architecture-soa/</link><pubDate>Thu, 17 Jul 2014 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/a-method-for-service-oriented-architecture-soa/</guid><description>&lt;p>When you adopt service oriented architecture (&lt;a href="https://en.wikipedia.org/wiki/Service-oriented_architecture">SOA&lt;/a>), the most important aspect of your architecture and high-level design step when building a new system is obviously decomposition of the system into the right services. A prudent way to decompose a system into services is to first identity what parts of the system is more likely to change more frequently. Thus, you decompose by volatility and set up dependencies such that you always have more volatile services calling less volatile services. Within the same level of volatility, of course, you would further decompose services by function if needed.&lt;/p></description></item><item><title>An Easy Service Proxy Executor for WCF</title><link>https://aashishkoirala.com/blog/tech/an-easy-service-proxy-executor-for-wcf/</link><pubDate>Thu, 15 May 2014 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/an-easy-service-proxy-executor-for-wcf/</guid><description>&lt;p>If you have adopted service oriented architecture (&lt;a href="https://en.wikipedia.org/wiki/Service-oriented_architecture">SOA&lt;/a>) and are using WCF as the hosting/communication mechanism for your internal services, chances are you are doing one of two things: you publish each service like any old WCF service and your other services which are consumers of said published service consume it through its WSDL; or you create shared libraries that include the contract information that both the service and its consumer reference. Both are somewhat cumbersome but can be managed. If all your services are internal, though, going the WSDL route is somewhat of an unnecessary overhead and is just a bit more unmanageable.&lt;/p></description></item></channel></rss>