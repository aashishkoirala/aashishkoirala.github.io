<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dotnetcore on Aashish Koirala</title><link>https://aashishkoirala.com/tags/dotnetcore/</link><description>Recent content in Dotnetcore on Aashish Koirala</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 21 Jul 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://aashishkoirala.com/tags/dotnetcore/index.xml" rel="self" type="application/rss+xml"/><item><title>Simple Console Application in .NET Core with DI and Configuration</title><link>https://aashishkoirala.com/blog/tech/simple-console-application-in-dotnet-core-with-di-and-configuration/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/simple-console-application-in-dotnet-core-with-di-and-configuration/</guid><description>&lt;p>While the .NET Core documentation and libraries do a good job of providing an easy way to get started with hosted apps (web or otherwise), it is somewhat lacking in terms of the same guidance for simple run-to-completion type console apps. You can write a simple &lt;code>Main()&lt;/code> method and do your stuff, but how do you get the advantage of the amazing configuration and dependency injection that you get out of the box with hosted apps? Surely, you could set up all that machinery and maybe create an &lt;code>IHostedService&lt;/code> implementation just to get going. Even then, you are still left with a hosted app that you have to deal with shutting down after your logic is done.&lt;/p></description></item><item><title>Working with Windows Containers in Kubernetes</title><link>https://aashishkoirala.com/blog/tech/working-with-windows-containers-in-kubernetes/</link><pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/working-with-windows-containers-in-kubernetes/</guid><description>&lt;p>Even though &lt;strong>Docker&lt;/strong> was built atop Linux containers and that is the majority of Docker usage out there, &lt;a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/">Windows Containers&lt;/a> have been a thing for a while now. They went mainstream in 2016, and one hopes &amp;ldquo;ready for primetime&amp;rdquo; with Windows Server 2019. Even though integration with Docker is getting tighter, if you are in the unfortunate position of having to use Windows Containers with &lt;strong>Kubernetes&lt;/strong>, you are going to have issues.&lt;/p></description></item><item><title>Running .NET Core Global Tools Without the SDK</title><link>https://aashishkoirala.com/blog/tech/running-dotnet-core-global-tools-without-the-sdk/</link><pubDate>Fri, 06 Sep 2019 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/running-dotnet-core-global-tools-without-the-sdk/</guid><description>&lt;p>&lt;a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools">.NET Core Global Tools&lt;/a> are pretty neat. If you are targetting developers with the .NET Core SDK installed on their machines and need to ship CLI tools, your job is made immensely easier. It is just as easy as shipping a NuGet package. However, once you get used to building these things, it is easy to fall into the trap of treating this shipping mechanism as if it were &lt;a href="https://chocolatey.org/">Chocolatey&lt;/a> (or &lt;em>apt-get&lt;/em>, or &lt;em>yum&lt;/em>, or what-have-you). It is certainly not that. The process of installing and upgrading your tools are handled by the .NET Core SDK - which alleviates you from having to create a self-contained package if you were shipping a ready-to-go tool - and this makes sense - global tools are a developer-targetted thing. You&amp;rsquo;re not supposed to use it to distribute end-user applications.&lt;/p></description></item><item><title>Listor- Showcasing React and .NET Core</title><link>https://aashishkoirala.com/blog/tech/listor-showcasing-react-and-dotnet-core/</link><pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/listor-showcasing-react-and-dotnet-core/</guid><description>&lt;p>For both &lt;a href="https://reactjs.org/">React&lt;/a> and for &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/">.NET Core&lt;/a> (specifically &lt;a href="https://www.asp.net/core/overview/aspnet-vnext">ASP.NET Core&lt;/a> and &lt;a href="https://docs.microsoft.com/en-us/ef/core/">Entity Framework Core&lt;/a>), I got sick of playing around with little prototypes and decided to build an application. &lt;a href="https://github.com/aashishkoirala/listor">Listor&lt;/a> is my first proper application I have built using both these technologies. It is a simple list-maker application- nothing fancy. But I have been using it since I put it up and it has come in handy quite a bit.&lt;/p>
&lt;p>I am quite impressed with .NET Core (or I should say &amp;ldquo;the new .NET&amp;rdquo; - to mean not just the .NET Core runtime, but .NET Standard, the new project system, ASP.NET Core, EF Core, and let&amp;rsquo;s say even the latest language improvements to C#). So much so, that it is going to suck a bit going back to writing traditional .NET Framework stuff for my day job.&lt;/p></description></item></channel></rss>