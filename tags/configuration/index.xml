<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Configuration on Aashish Koirala</title><link>https://aashishkoirala.com/tags/configuration/</link><description>Recent content in Configuration on Aashish Koirala</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 21 Jul 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://aashishkoirala.com/tags/configuration/index.xml" rel="self" type="application/rss+xml"/><item><title>Simple Console Application in .NET Core with DI and Configuration</title><link>https://aashishkoirala.com/blog/tech/simple-console-application-in-dotnet-core-with-di-and-configuration/</link><pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/simple-console-application-in-dotnet-core-with-di-and-configuration/</guid><description>&lt;p>While the .NET Core documentation and libraries do a good job of providing an easy way to get started with hosted apps (web or otherwise), it is somewhat lacking in terms of the same guidance for simple run-to-completion type console apps. You can write a simple &lt;code>Main()&lt;/code> method and do your stuff, but how do you get the advantage of the amazing configuration and dependency injection that you get out of the box with hosted apps? Surely, you could set up all that machinery and maybe create an &lt;code>IHostedService&lt;/code> implementation just to get going. Even then, you are still left with a hosted app that you have to deal with shutting down after your logic is done.&lt;/p></description></item></channel></rss>