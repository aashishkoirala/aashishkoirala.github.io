<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Wcf on Aashish Koirala</title><link>https://aashishkoirala.com/tags/wcf/</link><description>Recent content in Wcf on Aashish Koirala</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 02 Dec 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://aashishkoirala.com/tags/wcf/index.xml" rel="self" type="application/rss+xml"/><item><title>Beware of this WCF Serialization Pitfall</title><link>https://aashishkoirala.com/blog/tech/beware-of-this-wcf-serialization-pitfall/</link><pubDate>Tue, 02 Dec 2014 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/beware-of-this-wcf-serialization-pitfall/</guid><description>&lt;p>Ideally, one should avoid data contracts with complex graphs- especially with repeated references and definitely ones with circular references. Those can make your payload explode on serialization. With repeated references, you may run into an integrity issue on deserialization. With circular references, the serialization will enter a recursive loop and you will probably run into a stack overflow.&lt;/p>
&lt;p>Seeing that in certain situations, this becomes unavoidable, WCF has &lt;a href="https://msdn.microsoft.com/en-us/library/system.runtime.serialization.datacontractattribute.isreference(v=vs.110).aspx">a way&lt;/a> that you can tell it to preserve object references during serialization. You do this by setting &lt;em>IsReference&lt;/em> to &lt;strong>true&lt;/strong> on the &lt;em>DataContract&lt;/em> attribute that you use to decorate the composite type that is your data contract.&lt;/p></description></item><item><title>An Easy Service Proxy Executor for WCF</title><link>https://aashishkoirala.com/blog/tech/an-easy-service-proxy-executor-for-wcf/</link><pubDate>Thu, 15 May 2014 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/an-easy-service-proxy-executor-for-wcf/</guid><description>&lt;p>If you have adopted service oriented architecture (&lt;a href="https://en.wikipedia.org/wiki/Service-oriented_architecture">SOA&lt;/a>) and are using WCF as the hosting/communication mechanism for your internal services, chances are you are doing one of two things: you publish each service like any old WCF service and your other services which are consumers of said published service consume it through its WSDL; or you create shared libraries that include the contract information that both the service and its consumer reference. Both are somewhat cumbersome but can be managed. If all your services are internal, though, going the WSDL route is somewhat of an unnecessary overhead and is just a bit more unmanageable.&lt;/p></description></item><item><title>RudyMQ- A Rudimentary Message Queue for Windows</title><link>https://aashishkoirala.com/blog/tech/rudymq-a-rudimentary-message-queue-for-windows/</link><pubDate>Tue, 11 Feb 2014 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/rudymq-a-rudimentary-message-queue-for-windows/</guid><description>&lt;p>For some odd reason out of the blue, I got this hankering to build a message queue (albeit rudimentary - hence the name) from scratch. I&amp;rsquo;ve been working with MSMQ for a while now, mostly as a transport for WCF. As cool as it is, it can really get on your nerves at times. It is an enterprise grade product, after all, which means there are a lot of dials you can turn. If something is not right, you&amp;rsquo;ll get an error. If your experience has been the same as mine, you will recognize the dreaded &lt;em>insufficient resources&lt;/em> error that MSMQ gives you for almost any of a thousand things that can go wrong.&lt;/p></description></item></channel></rss>