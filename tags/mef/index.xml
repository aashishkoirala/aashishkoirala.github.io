<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mef on Aashish Koirala</title><link>https://aashishkoirala.com/tags/mef/</link><description>Recent content in Mef on Aashish Koirala</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 15 Oct 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://aashishkoirala.com/tags/mef/index.xml" rel="self" type="application/rss+xml"/><item><title>Diagnosing MEF Composition Errors</title><link>https://aashishkoirala.com/blog/tech/diagnosing-mef-composition-errors/</link><pubDate>Wed, 15 Oct 2014 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/diagnosing-mef-composition-errors/</guid><description>&lt;p>For all its goodness, if something goes wrong, problems with &lt;a href="https://aashishkoirala.com/blog/tech/mef-for-everything/">MEF&lt;/a> are terribly hard to diagnose. Thankfully, there&amp;rsquo;s an &lt;a href="https://blogs.msdn.microsoft.com/dsplaisted/2010/07/13/how-to-debug-and-diagnose-mef-failures/">article&lt;/a> out there by &lt;a href="https://social.msdn.microsoft.com/profile/dsplaisted">Daniel Plaisted&lt;/a> at Microsoft that goes into great detail into all the things that can go wrong with MEF and how to get to the bottom of each one. I have it bookmarked, and if you work a lot with MEF, you should too. The one area that I find most useful, though, is figuring out composition-time errors using tracing.&lt;/p></description></item><item><title>Handling Duplicate Libraries with MEF</title><link>https://aashishkoirala.com/blog/tech/handling-duplicate-libraries-with-mef/</link><pubDate>Fri, 09 Aug 2013 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/handling-duplicate-libraries-with-mef/</guid><description>&lt;p>While building the composition/DI piece for the &lt;a href="http://aashishkoirala.github.io/commons/">Commons Library&lt;/a>, one problem I ran into was the fact that if you told MEF to load assemblies from a number of different places - and they all had copies of the same library (which is possible especially with common dependencies), MEF would load the exports in each assembly as many times as it finds it. What you end up with then is a whole bunch of matching exports for a contract that you expect only one of.&lt;/p></description></item><item><title>MEF for everything!</title><link>https://aashishkoirala.com/blog/tech/mef-for-everything/</link><pubDate>Wed, 07 Aug 2013 00:00:00 +0000</pubDate><guid>https://aashishkoirala.com/blog/tech/mef-for-everything/</guid><description>&lt;p>In the first of a series of blogs around my &lt;a href="https://aashishkoirala.com/blog/tech/the-commons-library/">Commons Library&lt;/a>, I want to shed more light on my choice of MEF as the underlying mechanism for the &lt;code>AK.Commons.Composition&lt;/code> namespace - which handles dependency injection &lt;strong>as well as&lt;/strong> extensibility or plugin type stuff. I like its attribute based syntax, choice of different types of catalogs and dynamic discovery (and yes, I am not using dynamic discovery just yet but I intend to; the same goes for taking advantage of different types of catalogs). The following three features, however, stood out for me:&lt;/p></description></item></channel></rss>