---
title: Writing a WS-Federation Based STS using WIF
slug: writing-a-ws-federation-based-sts-using-wif
aliases:
- /blog/writing-a-ws-federation-based-sts-using-wif
date: 2015-02-10
draft: false
tags:
- csharp
- dotnet
- wsfed
- security
- sts
- wif
---
Even though [SAML](https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language) and [WS-*](https://en.wikipedia.org/wiki/WS-Security) have started to be looked upon as the old guard of security protocols with the popularity of [OAuth 2](http://oauth.net/2/), they are not without their merits. For one, they are [inherently more secure than OAuth](https://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/) (in fact, you need to rely on a separate underlying secure transport for OAuth to be considered secure- and if you are someone who believes [SSL is broken](http://www.zdnet.com/article/how-the-nsa-and-your-boss-can-intercept-and-break-ssl/), then OAuth is practically insecure). It just so happens that their demerits are very visible to someone trying to implement or integrate them. OAuth, by contrast, is much simpler and easier to implement- and for most purposes, secure enough. If you have settled on [WS-Federation](https://msdn.microsoft.com/en-us/library/bb498017.aspx) as your protocol of choice, [Windows Identity Foundation (WIF)](https://msdn.microsoft.com/en-us/library/hh377151(v=vs.110).aspx) is most likely going to be your de-facto choice. While powerful, WIF as a library is not what one would call "easy to use". If it's cumbersome when you use it as a relying party, the complexity is ten-fold if you try to build a security token service (STS) based on it.

I decided to take on the challenge and embarked on building a [central login system](http://aashishkoirala.github.io/login/) (i.e. passive STS) that I could use for all of my applications. I mostly don't like to maintain my own user database, so the central login system would then provide a hub for the user to login using any of the various identity providers out there such as Google or Facebook. The main advantage would be that the user would need to login once and be able to use all my applications. The initial plan was to make it protocol agnostic - i.e. something that will look at the incoming request, figure out what kind of request it is, and then delegate to an appropriate protocol handler. This way, the application would be able to support WS-Federation, SAML 2, OAuth 2, what-have-you, as needed. However, I saw what a great job [IdentityServer](https://github.com/IdentityServer) has done in terms of providing a library you can easily build an OAuth based STS with - so that made me not want to pursue the OAuth path at all for this instance. My plan is to someday just build the next version of this as an OAuth STS using [IdentityServer3](https://github.com/IdentityServer/IdentityServer3).

With that said, if you look at the source code ([available here](https://github.com/aashishkoirala/login)), you will see that there is a protocol-agnostic pattern with a WS-Federation implementation. The application uses Windows Identity Foundation (WIF) as its core component. It acts as a passive **STS (Security Token Service)** while dividing the role of **IP (Identity Provider)** between the target application (or "**Relying Party"**) and one or more third-party providers such as Google or Facebook. The third-party providers are used for authentication, but the responsibility of storing whatever user information is needed by each application is the responsibility of that application (thus my statement that the identity provider role is divided between the Relying Party and the third-party Identity Providers). The entry point of the WS-Federation communication logic is in the [WsFedLoginRequestProcessor](https://github.com/aashishkoirala/login/blob/master/src/AK.Login.Application/WsFed/WsFedLoginRequestProcessor.cs) class, specifically the **ProcessSignIn** method.

Each Relying Party is registered with the application through configuration - needs to have three settings populated: the realm URI (a unique identifier for the party - an example being **urn:**_ApplicationName_), the reply-to URL (the URL that this application will redirect to once the user is authenticated. This is usually the main entry point URL for the Relying Party application) and the "login service URL". The Relying Party needs to implement a WCF service with a predefined contract (defined in **ILoginService** - available in the [Commons Library](https://github.com/aashishkoirala/commons). The service is responsible for providing information about the application as well as any given user to the STS, as well as exposing a way to create new users. The Relying Party application then needs to be configured for WIF and with the STS designated as the token issuer. There are methods available in the Commons Library that facilitate this. Communication between the Relying Party and the STS is encrypted and signed using a shared X.509 certificate.

When you navigate to a protected endpoint in the Relying Party, and are not authenticated, you are redirected to the login page hosted by the STS. This redirection request is generated by WIF and follows standard WS-Federation protocol. The STS then uses the realm information passed in the request to look up information about the party. It gets more information from the Relying Party using the **ILoginService** WCF endpoint. It uses this to display application-specific information in the login page. From the login page, you can use Google (using it's OAuth API) or Facebook (using its JavaScript API) to authenticate yourself. The STS then communicates with the Relying Party using the **ILoginService** WCF endpoint to see if a user matching credentials just provided by Google or Facebook exists. If so, it uses this information to instruct WIF to write an encrypted session token cookie, and redirects back to the Relying Party reply-to URL - where it is now authenticated thanks to the encrypted session token cookie.

If a user is not found, the STS prompts you to enter a display name for the user that is going to be newly created. Once you provide the information, the **ILoginService** WCF endpoint is again used to create a new user record in the Relying Party application, and the rest of the process is same as above. When you logout from the Relying Party application, WIF sends a logout WS-Federation message to the STS which takes care of processing the logout operation.